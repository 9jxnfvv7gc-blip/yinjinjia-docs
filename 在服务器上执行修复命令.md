# 在服务器上执行修复命令

## 🚀 方法：直接在服务器上执行Python脚本修复

### 在Workbench终端执行以下命令：

```bash
# 停止服务器
pkill -f video_server.py
systemctl stop video-server

# 创建修复脚本
cat > /tmp/fix_code.py << 'ENDOFFILE'
#!/usr/bin/env python3
import os
import re

file_path = '/root/video_server/video_server.py'

# 备份
os.system(f'cp {file_path} {file_path}.bak10')

# 读取文件
with open(file_path, 'r', encoding='utf-8') as f:
    lines = f.readlines()

# 修改
new_lines = []
i = 0
while i < len(lines):
    line = lines[i]
    
    # 修改title行
    if 'title = os.path.splitext(f)[0]' in line:
        indent = len(line) - len(line.lstrip())
        new_lines.append(' ' * indent + '# 使用完整文件名作为title\n')
        new_lines.append(' ' * indent + 'title = f\n')
        i += 1
        continue
    
    # 修改url行（需要找到url_prefix那一行）
    if "url_prefix = '/music/' if ext in music_extensions else '/video/'" in line:
        new_lines.append(line)
        i += 1
        # 跳过原来的url构建，添加新的URL构建逻辑
        # 找到file_list.append的位置
        while i < len(lines) and 'file_list.append' not in lines[i]:
            if "'url': f'{url_prefix}{relative_path}'" in lines[i] or '"url": f\'{url_prefix}{relative_path}\'' in lines[i]:
                # 替换这一行
                indent = len(lines[i]) - len(lines[i].lstrip())
                # 插入URL构建代码
                new_lines.append(' ' * indent + '# 构建完整的URL（使用服务器IP）\n')
                new_lines.append(' ' * indent + '# 获取服务器IP（从请求头或使用默认值）\n')
                new_lines.append(' ' * indent + "server_host = self.headers.get('Host', '47.243.177.166:8081')\n")
                new_lines.append(' ' * indent + "if ':' not in server_host:\n")
                new_lines.append(' ' * indent + '    server_host = f"{server_host}:8081"\n')
                new_lines.append(' ' * indent + "full_url = f\"http://{server_host}/{relative_path.replace(os.sep, '/')}\"\n")
                # 替换url行
                new_lines.append(' ' * indent + "'url': full_url,\n")
                i += 1
                continue
            new_lines.append(lines[i])
            i += 1
        continue
    
    # 修改id行
    if "'id': file_path," in line:
        indent = len(line) - len(line.lstrip())
        new_lines.append(' ' * indent + "'id': f,  # 使用文件名作为id\n")
        i += 1
        continue
    
    new_lines.append(line)
    i += 1

# 写回文件
with open(file_path, 'w', encoding='utf-8') as f:
    f.writelines(new_lines)

# 检查语法
import subprocess
result = subprocess.run(['python3', '-m', 'py_compile', file_path], capture_output=True)
if result.returncode == 0:
    print('✅ 代码修改成功，语法检查通过')
else:
    print('❌ 语法错误，正在恢复备份...')
    os.system(f'cp {file_path}.bak10 {file_path}')
    print(result.stderr.decode())
ENDOFFILE

# 执行修复脚本
python3 /tmp/fix_code.py

# 重新启动服务器测试
cd /root/video_server
python3 video_server.py > /tmp/video_server.log 2>&1 &
sleep 2

# 测试API
curl "http://localhost:8081/api/list/$(python3 -c "from urllib.parse import quote; print(quote('原创视频'))")"
```

---

## 📋 执行后

把输出结果发给我，特别是：
1. **修复脚本的输出**（是否成功）
2. **API返回的JSON结果**

---

**直接复制上面的命令到Workbench终端执行！** 🚀

